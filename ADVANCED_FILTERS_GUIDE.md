# 高级滤镜功能说明

## 概述

本项目已实现多种经典的图像处理算法，包括平滑算子、锐化算子和边缘检测算子。这些算法都是数字图像处理教材中的经典算法。

## 已实现的算法

### 1. 平滑算子（去噪）

#### 1.1 中值滤波 (Median Filter)
- **用途**: 去除椒盐噪声，保持边缘
- **原理**: 使用邻域像素的中值替换当前像素
- **参数**: 
  - 半径 (radius): 1-5 像素，控制滤波窗口大小
- **特点**: 
  - 非线性滤波
  - 对椒盐噪声效果极佳
  - 能够较好地保持边缘

#### 1.2 高斯模糊 (Gaussian Blur)
- **用途**: 平滑图像，去除高斯噪声
- **原理**: 使用高斯函数生成卷积核，对图像进行加权平均
- **参数**: 
  - 标准差 (σ): 0.5-5.0，控制模糊程度
- **特点**: 
  - 线性滤波
  - 平滑效果自然
  - 符合视觉感知

### 2. 锐化算子（增强边缘）

#### 2.1 Laplacian 锐化
- **用途**: 增强图像边缘和细节
- **原理**: 使用二阶微分算子检测边缘，然后叠加到原图
- **卷积核**:
```
[  0, -1,  0 ]
[ -1,  4, -1 ]
[  0, -1,  0 ]
```
- **特点**: 
  - 对噪声敏感
  - 能够检测各个方向的边缘
  - 增强效果明显

### 3. 边缘检测算子

#### 3.1 Sobel 算子
- **用途**: 检测图像边缘，计算梯度
- **原理**: 使用两个3×3卷积核分别检测水平和垂直方向的梯度
- **卷积核**:
  - 水平方向 (Gx):
    ```
    [ -1,  0,  1 ]
    [ -2,  0,  2 ]
    [ -1,  0,  1 ]
    ```
  - 垂直方向 (Gy):
    ```
    [ -1, -2, -1 ]
    [  0,  0,  0 ]
    [  1,  2,  1 ]
    ```
- **特点**: 
  - 对噪声有一定抑制能力
  - 边缘定位准确
  - 应用最广泛的边缘检测算子

#### 3.2 Prewitt 算子
- **用途**: 边缘检测，类似 Sobel
- **原理**: 使用简化的梯度算子
- **卷积核**:
  - 水平方向 (Gx):
    ```
    [ -1,  0,  1 ]
    [ -1,  0,  1 ]
    [ -1,  0,  1 ]
    ```
  - 垂直方向 (Gy):
    ```
    [ -1, -1, -1 ]
    [  0,  0,  0 ]
    [  1,  1,  1 ]
    ```
- **特点**: 
  - 计算简单
  - 对噪声敏感度略高于 Sobel
  - 边缘检测效果良好

#### 3.3 Roberts 算子
- **用途**: 快速边缘检测
- **原理**: 使用2×2对角线方向的差分算子
- **计算方式**:
  - Gx = P(i,j) - P(i+1,j+1)
  - Gy = P(i+1,j) - P(i,j+1)
- **特点**: 
  - 计算最简单
  - 对噪声非常敏感
  - 适合边缘清晰的图像

## 使用方法

### 在 UI 中使用

1. **导入图片**: 点击"导入"按钮或拖拽图片到画布
2. **选择滤镜**: 在侧边栏的"高级滤镜"部分
3. **调整参数**: 
   - 平滑算子：使用滑块调整参数
   - 锐化和边缘检测：直接点击按钮应用
4. **查看效果**: 使用底部的"处理后"、"原图"、"对比"按钮切换查看模式
5. **撤销/重做**: 使用工具栏的撤销/重做按钮
6. **导出结果**: 点击"导出"按钮保存处理后的图片

### 算法选择建议

#### 去噪场景
- **椒盐噪声**: 使用中值滤波
- **高斯噪声**: 使用高斯模糊
- **轻微噪声**: 使用较小的滤波半径/标准差

#### 锐化场景
- **增强细节**: 使用 Laplacian 锐化
- **注意**: 锐化会放大噪声，建议先去噪再锐化

#### 边缘检测场景
- **通用边缘检测**: 使用 Sobel 算子
- **简单快速检测**: 使用 Roberts 算子
- **需要平滑边缘**: 使用 Prewitt 算子

## 算法实现细节

### 中值滤波
```typescript
// 对每个像素的邻域进行排序，取中值
for (let y = radius; y < height - radius; y++) {
  for (let x = radius; x < width - radius; x++) {
    // 收集邻域像素值
    const values = [];
    for (let ky = -radius; ky <= radius; ky++) {
      for (let kx = -radius; kx <= radius; kx++) {
        values.push(pixel[y+ky][x+kx]);
      }
    }
    // 排序并取中值
    values.sort();
    result[y][x] = values[mid];
  }
}
```

### 高斯模糊
```typescript
// 生成高斯核
const kernel = [];
for (let y = -radius; y <= radius; y++) {
  for (let x = -radius; x <= radius; x++) {
    kernel[y][x] = exp(-(x*x + y*y) / (2*sigma*sigma));
  }
}
// 归一化
kernel = kernel / sum(kernel);
// 卷积
result = convolve(image, kernel);
```

### 边缘检测
```typescript
// 计算梯度
for (let y = 1; y < height - 1; y++) {
  for (let x = 1; x < width - 1; x++) {
    let gx = 0, gy = 0;
    // 应用卷积核
    for (let ky = -1; ky <= 1; ky++) {
      for (let kx = -1; kx <= 1; kx++) {
        gx += pixel[y+ky][x+kx] * kernelX[ky][kx];
        gy += pixel[y+ky][x+kx] * kernelY[ky][kx];
      }
    }
    // 计算梯度幅值
    magnitude = sqrt(gx*gx + gy*gy);
    result[y][x] = magnitude;
  }
}
```

## 性能优化

1. **防抖处理**: 滑块调整时使用100ms防抖，避免频繁计算
2. **离屏渲染**: 使用离屏Canvas进行图像处理，提高性能
3. **边界处理**: 对图像边缘像素进行特殊处理，避免越界
4. **数据类型**: 使用 Uint8ClampedArray 自动限制像素值范围

## 注意事项

1. **处理顺序**: 建议先去噪，再进行其他处理
2. **参数选择**: 从小参数开始尝试，逐步增大
3. **边缘检测**: 边缘检测会将图像转换为灰度图
4. **性能**: 高斯模糊和中值滤波在大图像上可能较慢
5. **撤销功能**: 所有操作都支持撤销/重做

## 扩展性

代码采用模块化设计，易于添加新的滤镜算法：

1. 在 `advancedFilters.ts` 中实现新算法
2. 在 `filters.ts` 的 `applyFilter` 中添加 case
3. 在 `Sidebar.tsx` 中添加 UI 控件
4. 更新类型定义和参数传递

## 参考资料

- 冈萨雷斯《数字图像处理》
- 经典图像处理算法
- OpenCV 文档

## 更新日志

- 2024-11-05: 实现中值滤波、高斯模糊、Laplacian锐化、Sobel/Prewitt/Roberts边缘检测

